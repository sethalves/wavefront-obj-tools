#! /bin/sh
#| -*- scheme -*-
exec csi -include-path /usr/local/share/scheme -s $0 "$@"
|#
(use r7rs)
(include "snow/assert.sld")
(include "snow/input-parse.sld")
(include "foldling/command-line.sld")
(include "seth/cout.sld")
(include "seth/math-3d.sld")
(include "seth/obj-model.sld")


(import (scheme base)
        (scheme write)
        (scheme process-context)
        (seth obj-model)
        (foldling command-line))


(define (main-program)
  (define (usage why)
    (display why)
    (newline)
    (display (car (command-line)))
    (display " [args] input-file.obj ...\n")
    (display "  -s scale-factor           scale points by factor\n")
    (display "  -d max-dimension          scale model to max-dimension\n")
    (display "  -c                        reuse coincident points\n")
    (display
     "  -n                        flip faces so outsides face as normals\n")
    (display "  -p                        print information about model\n")
    (display "  -t x y z                  translate model by an offset\n")
    (display "  -o output-filename        instead of stdout\n")
    (exit 1))

  (let* ((args (parse-command-line
                `(((-s -d) ,string->number)
                  (-o output-file)
                  ((-c -n -p))
                  (-t x y z)
                  (-?) (-h))))
         (scale #f)
         (dimension #f)
         (input-files '())
         (output-file #f)
         (compact-points #f)
         (translate-by #f)
         (fix-face-normals #f)
         (print-info #f)
         (output-port (current-output-port)))

    (for-each
     (lambda (arg)
       (case (car arg)
         ((-? -h) (usage ""))
         ((-s)
          (if scale (usage "give -s only once"))
          (set! scale (cadr arg)))
         ((-d)
          (if dimension (usage "give -d only once"))
          (set! dimension (cadr arg)))
         ((-o)
          (if output-file (usage "give -o only once"))
          (set! output-file (cadr arg)))
         ((-c)
          (if compact-points (usage "give -c only once"))
          (set! compact-points #t))
         ((-p)
          (if print-info (usage "give -p only once"))
          (set! print-info #t))
         ((-n)
          (if fix-face-normals (usage "give -n only once"))
          (set! fix-face-normals #t))
         ((-t)
          (if translate-by (usage "give -t only once"))
          (set! translate-by (list->vector (map string->number (cdr arg)))))
         ((--)
          (set! input-files (cdr arg)))))
     args)

    (if (and scale dimension) (usage "don't use both -s and -d"))
    (if (null? input-files) (usage "give at least one input filename"))
    (if output-file
        (set! output-port (open-output-file output-file)))

    (let ((model (make-model '() '() '())))
      (let loop ((input-files input-files))
        (cond ((null? input-files)
               (if compact-points (compact-obj-model model))
               (if fix-face-normals (fix-implied-normals model))
               (if translate-by (translate-model model translate-by))
               (cond (scale (scale-model model scale))
                     (dimension (size-model model dimension)))
               (write-obj-model model output-port)
               (if output-file (close-output-port output-port)))
              (else
               (read-obj-model-file (car input-files) model)
               (loop (cdr input-files)))))

      (cond (print-info
             (let ((aa-box (model-aa-box model)))
               (display "aa-box: " (current-error-port))
               (write `(,(aa-box-low-corner aa-box)
                        ,(aa-box-high-corner aa-box)) (current-error-port))
               (newline (current-error-port) (current-error-port))
               (display "dimensions: " (current-error-port))
               (write `(,(model-dimensions model)) (current-error-port))
               (newline (current-error-port))
               ))))
    ))

(main-program)
